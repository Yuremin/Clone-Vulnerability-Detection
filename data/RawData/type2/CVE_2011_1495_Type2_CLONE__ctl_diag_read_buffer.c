static long
CVE_2011_1495_VULN__ctl_diag_read_buffer(void __user *arg, enum block_state state)
{

	struct mpt2_diag_read_buffer karg;
	struct mpt2_diag_read_buffer __user *uarg = arg;
	struct MPT2SAS_ADAPTER *type2Clone_2;
	void *request_data, *diag_data;
	Mpi2DiagBufferPostRequest_t *mpi_request;
	Mpi2DiagBufferPostReply_t *mpi_reply;
	int type2Clone_4, i;
	u8 type2Clone_3;
	unsigned long timeleft;
	u16 smid;
	u16 ioc_status;
	u8 type2Clone_1 = 0;

	if (copy_from_user(&karg, arg, sizeof(karg))) {
		printk(KERN_ERR "failure at %s:%d/%s()!\n",
		    __FILE__, __LINE__, __func__);
		return -EFAULT;
	}
	if (_ctl_verify_adapter(karg.hdr.ioc_number, &type2Clone_2) == -1 || !type2Clone_2)
		return -ENODEV;

	dctlprintk(type2Clone_2, printk(MPT2SAS_INFO_FMT "%s\n", type2Clone_2->name,
	    __func__));

	type2Clone_3 = karg.unique_id & 0x000000ff;
	if (!_ctl_diag_capability(type2Clone_2, type2Clone_3)) {
		printk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "
		    "type2Clone_3(0x%02x)\n", type2Clone_2->name, __func__, type2Clone_3);
		return -EPERM;
	}

	if (karg.unique_id != type2Clone_2->unique_id[type2Clone_3]) {
		printk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "
		    "registered\n", type2Clone_2->name, __func__, karg.unique_id);
		return -EINVAL;
	}

	request_data = type2Clone_2->diag_buffer[type2Clone_3];
	if (!request_data) {
		printk(MPT2SAS_ERR_FMT "%s: doesn't have buffer for "
		    "type2Clone_3(0x%02x)\n", type2Clone_2->name, __func__, type2Clone_3);
		return -ENOMEM;
	}

	if ((karg.starting_offset % 4) || (karg.bytes_to_read % 4)) {
		printk(MPT2SAS_ERR_FMT "%s: either the starting_offset "
		    "or bytes_to_read are not 4 byte aligned\n", type2Clone_2->name,
		    __func__);
		return -EINVAL;
	}

	diag_data = (void *)(request_data + karg.starting_offset);
	dctlprintk(type2Clone_2, printk(MPT2SAS_INFO_FMT "%s: diag_buffer(%p), "
	    "offset(%d), sz(%d)\n", type2Clone_2->name, __func__,
	    diag_data, karg.starting_offset, karg.bytes_to_read));

	if (copy_to_user((void __user *)uarg->diagnostic_data,
	    diag_data, karg.bytes_to_read)) {
		printk(MPT2SAS_ERR_FMT "%s: Unable to write "
		    "mpt_diag_read_buffer_t data @ %p\n", type2Clone_2->name,
		    __func__, diag_data);
		return -EFAULT;
	}

	if ((karg.flags & MPT2_FLAGS_REREGISTER) == 0)
		return 0;

	dctlprintk(type2Clone_2, printk(MPT2SAS_INFO_FMT "%s: Reregister "
		"type2Clone_3(0x%02x)\n", type2Clone_2->name, __func__, type2Clone_3));
	if ((type2Clone_2->diag_buffer_status[type2Clone_3] &
	    MPT2_DIAG_BUFFER_IS_RELEASED) == 0) {
		dctlprintk(type2Clone_2, printk(MPT2SAS_INFO_FMT "%s: "
		    "type2Clone_3(0x%02x) is still registered\n", type2Clone_2->name,
		     __func__, type2Clone_3));
		return 0;
	}
	/* Get a free request frame and save the message context.
	*/
	if (state == NON_BLOCKING && !mutex_trylock(&type2Clone_2->ctl_cmds.mutex))
		return -EAGAIN;
	else if (mutex_lock_interruptible(&type2Clone_2->ctl_cmds.mutex))
		return -ERESTARTSYS;

	if (type2Clone_2->ctl_cmds.status != MPT2_CMD_NOT_USED) {
		printk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",
		    type2Clone_2->name, __func__);
		type2Clone_4 = -EAGAIN;
		goto out;
	}

	smid = mpt2sas_base_get_smid(type2Clone_2, type2Clone_2->ctl_cb_idx);
	if (!smid) {
		printk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",
		    type2Clone_2->name, __func__);
		type2Clone_4 = -EAGAIN;
		goto out;
	}

	type2Clone_4 = 0;
	type2Clone_2->ctl_cmds.status = MPT2_CMD_PENDING;
	memset(type2Clone_2->ctl_cmds.reply, 0, type2Clone_2->reply_sz);
	mpi_request = mpt2sas_base_get_msg_frame(type2Clone_2, smid);
	type2Clone_2->ctl_cmds.smid = smid;

	mpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;
	mpi_request->BufferType = type2Clone_3;
	mpi_request->BufferLength =
	    cpu_to_le32(type2Clone_2->diag_buffer_sz[type2Clone_3]);
	mpi_request->BufferAddress =
	    cpu_to_le64(type2Clone_2->diag_buffer_dma[type2Clone_3]);
	for (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)
		mpi_request->ProductSpecific[i] =
			cpu_to_le32(type2Clone_2->product_specific[type2Clone_3][i]);
	mpi_request->VF_ID = 0; /* TODO */
	mpi_request->VP_ID = 0;

	mpt2sas_base_put_smid_default(type2Clone_2, smid);
	init_completion(&type2Clone_2->ctl_cmds.done);
	timeleft = wait_for_completion_timeout(&type2Clone_2->ctl_cmds.done,
	    MPT2_IOCTL_DEFAULT_TIMEOUT*HZ);

	if (!(type2Clone_2->ctl_cmds.status & MPT2_CMD_COMPLETE)) {
		printk(MPT2SAS_ERR_FMT "%s: timeout\n", type2Clone_2->name,
		    __func__);
		_debug_dump_mf(mpi_request,
		    sizeof(Mpi2DiagBufferPostRequest_t)/4);
		if (!(type2Clone_2->ctl_cmds.status & MPT2_CMD_RESET))
			type2Clone_1 = 1;
		goto issue_host_reset;
	}

	/* process the completed Reply Message Frame */
	if ((type2Clone_2->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {
		printk(MPT2SAS_ERR_FMT "%s: no reply message\n",
		    type2Clone_2->name, __func__);
		type2Clone_4 = -EFAULT;
		goto out;
	}

	mpi_reply = type2Clone_2->ctl_cmds.reply;
	ioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;

	if (ioc_status == MPI2_IOCSTATUS_SUCCESS) {
		type2Clone_2->diag_buffer_status[type2Clone_3] |=
		    MPT2_DIAG_BUFFER_IS_REGISTERED;
		dctlprintk(type2Clone_2, printk(MPT2SAS_INFO_FMT "%s: success\n",
		    type2Clone_2->name, __func__));
	} else {
		printk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "
		    "log_info(0x%08x)\n", type2Clone_2->name, __func__,
		    ioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));
		type2Clone_4 = -EFAULT;
	}

 issue_host_reset:
	if (type2Clone_1)
		mpt2sas_base_hard_reset_handler(type2Clone_2, CAN_SLEEP,
		    FORCE_BIG_HAMMER);

 out:

	type2Clone_2->ctl_cmds.status = MPT2_CMD_NOT_USED;
	mutex_unlock(&type2Clone_2->ctl_cmds.mutex);
	return type2Clone_4;

}