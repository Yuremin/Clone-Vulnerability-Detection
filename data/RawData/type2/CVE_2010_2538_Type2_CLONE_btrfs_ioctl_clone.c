static noinline long CVE_2010_2538_VULN_btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
				       u64 off, u64 olen, u64 destoff)
{

	struct type2Clone_5 *type2Clone_5 = fdentry(file)->d_inode;
	struct btrfs_root *root = BTRFS_I(type2Clone_5)->root;
	struct file *src_file;
	struct type2Clone_5 *type2Clone_1;
	struct btrfs_trans_handle *trans;
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	char *buf;
	struct btrfs_key key;
	u32 nritems;
	int slot;
	int type2Clone_3;
	u64 type2Clone_2 = olen;
	u64 bs = root->fs_info->sb->s_blocksize;
	u64 hint_byte;

	/*
	 * TODO:
	 * - split compressed inline extents.  annoying: we need to
	 *   decompress into destination's address_space (the file offset
	 *   may change, so source mapping won't do), then recompress (or
	 *   otherwise reinsert) a subrange.
	 * - allow ranges within the same file to be cloned (provided
	 *   they don't overlap)?
	 */

	/* the destination must be opened for writing */
	if (!(file->f_mode & FMODE_WRITE))
		return -EINVAL;

	type2Clone_3 = mnt_want_write(file->f_path.mnt);
	if (type2Clone_3)
		return type2Clone_3;

	src_file = fget(srcfd);
	if (!src_file) {
		type2Clone_3 = -EBADF;
		goto out_drop_write;
	}

	type2Clone_1 = src_file->f_dentry->d_inode;

	type2Clone_3 = -EINVAL;
	if (type2Clone_1 == type2Clone_5)
		goto out_fput;

	/* the type2Clone_1 must be open for reading */
	if (!(src_file->f_mode & FMODE_READ))
		goto out_fput;

	type2Clone_3 = -EISDIR;
	if (S_ISDIR(type2Clone_1->i_mode) || S_ISDIR(type2Clone_5->i_mode))
		goto out_fput;

	type2Clone_3 = -EXDEV;
	if (type2Clone_1->i_sb != type2Clone_5->i_sb || BTRFS_I(type2Clone_1)->root != root)
		goto out_fput;

	type2Clone_3 = -ENOMEM;
	buf = vmalloc(btrfs_level_size(root, 0));
	if (!buf)
		goto out_fput;

	path = btrfs_alloc_path();
	if (!path) {
		vfree(buf);
		goto out_fput;
	}
	path->reada = 2;

	if (type2Clone_5 < type2Clone_1) {
		mutex_lock(&type2Clone_5->i_mutex);
		mutex_lock(&type2Clone_1->i_mutex);
	} else {
		mutex_lock(&type2Clone_1->i_mutex);
		mutex_lock(&type2Clone_5->i_mutex);
	}

	/* determine range to clone */
	type2Clone_3 = -EINVAL;
	if (off >= type2Clone_1->i_size || off + type2Clone_2 > type2Clone_1->i_size)
		goto out_unlock;
	if (type2Clone_2 == 0)
		olen = type2Clone_2 = type2Clone_1->i_size - off;
	/* if we extend to eof, continue to block boundary */
	if (off + type2Clone_2 == type2Clone_1->i_size)
		type2Clone_2 = ((type2Clone_1->i_size + bs-1) & ~(bs-1))
			- off;

	/* verify the end result is block aligned */
	if ((off & (bs-1)) ||
	    ((off + type2Clone_2) & (bs-1)))
		goto out_unlock;

	/* do any pending delalloc/csum calc on type2Clone_1, one way or
	   another, and lock file content */
	while (1) {
		struct btrfs_ordered_extent *ordered;
		lock_extent(&BTRFS_I(type2Clone_1)->io_tree, off, off+type2Clone_2, GFP_NOFS);
		ordered = btrfs_lookup_first_ordered_extent(type2Clone_5, off+type2Clone_2);
		if (BTRFS_I(type2Clone_1)->delalloc_bytes == 0 && !ordered)
			break;
		unlock_extent(&BTRFS_I(type2Clone_1)->io_tree, off, off+type2Clone_2, GFP_NOFS);
		if (ordered)
			btrfs_put_ordered_extent(ordered);
		btrfs_wait_ordered_range(type2Clone_1, off, off+type2Clone_2);
	}

	trans = btrfs_start_transaction(root, 1);
	BUG_ON(!trans);

	/* punch hole in destination first */
	btrfs_drop_extents(trans, type2Clone_5, off, off + type2Clone_2, &hint_byte, 1);

	/* clone data */
	key.objectid = type2Clone_1->i_ino;
	key.type = BTRFS_EXTENT_DATA_KEY;
	key.offset = 0;

	while (1) {
		/*
		 * note the key will change type as we walk through the
		 * tree.
		 */
		type2Clone_3 = btrfs_search_slot(trans, root, &key, path, 0, 0);
		if (type2Clone_3 < 0)
			goto out;

		nritems = btrfs_header_nritems(path->nodes[0]);
		if (path->slots[0] >= nritems) {
			type2Clone_3 = btrfs_next_leaf(root, path);
			if (type2Clone_3 < 0)
				goto out;
			if (type2Clone_3 > 0)
				break;
			nritems = btrfs_header_nritems(path->nodes[0]);
		}
		leaf = path->nodes[0];
		slot = path->slots[0];

		btrfs_item_key_to_cpu(leaf, &key, slot);
		if (btrfs_key_type(&key) > BTRFS_EXTENT_DATA_KEY ||
		    key.objectid != type2Clone_1->i_ino)
			break;

		if (btrfs_key_type(&key) == BTRFS_EXTENT_DATA_KEY) {
			struct btrfs_file_extent_item *extent;
			int type;
			u32 size;
			struct btrfs_key new_key;
			u64 disko = 0, diskl = 0;
			u64 datao = 0, type2Clone_4 = 0;
			u8 comp;

			size = btrfs_item_size_nr(leaf, slot);
			read_extent_buffer(leaf, buf,
					   btrfs_item_ptr_offset(leaf, slot),
					   size);

			extent = btrfs_item_ptr(leaf, slot,
						struct btrfs_file_extent_item);
			comp = btrfs_file_extent_compression(leaf, extent);
			type = btrfs_file_extent_type(leaf, extent);
			if (type == BTRFS_FILE_EXTENT_REG ||
			    type == BTRFS_FILE_EXTENT_PREALLOC) {
				disko = btrfs_file_extent_disk_bytenr(leaf,
								      extent);
				diskl = btrfs_file_extent_disk_num_bytes(leaf,
								 extent);
				datao = btrfs_file_extent_offset(leaf, extent);
				type2Clone_4 = btrfs_file_extent_num_bytes(leaf,
								    extent);
			} else if (type == BTRFS_FILE_EXTENT_INLINE) {
				/* take upper bound, may be compressed */
				type2Clone_4 = btrfs_file_extent_ram_bytes(leaf,
								    extent);
			}
			btrfs_release_path(root, path);

			if (key.offset + type2Clone_4 < off ||
			    key.offset >= off+type2Clone_2)
				goto next;

			memcpy(&new_key, &key, sizeof(new_key));
			new_key.objectid = type2Clone_5->i_ino;
			new_key.offset = key.offset + destoff - off;

			if (type == BTRFS_FILE_EXTENT_REG ||
			    type == BTRFS_FILE_EXTENT_PREALLOC) {
				type2Clone_3 = btrfs_insert_empty_item(trans, root, path,
							      &new_key, size);
				if (type2Clone_3)
					goto out;

				leaf = path->nodes[0];
				slot = path->slots[0];
				write_extent_buffer(leaf, buf,
					    btrfs_item_ptr_offset(leaf, slot),
					    size);

				extent = btrfs_item_ptr(leaf, slot,
						struct btrfs_file_extent_item);

				if (off > key.offset) {
					datao += off - key.offset;
					type2Clone_4 -= off - key.offset;
				}

				if (key.offset + type2Clone_4 > off + type2Clone_2)
					type2Clone_4 = off + type2Clone_2 - key.offset;

				/* disko == 0 means it's a hole */
				if (!disko)
					datao = 0;

				btrfs_set_file_extent_offset(leaf, extent,
							     datao);
				btrfs_set_file_extent_num_bytes(leaf, extent,
								type2Clone_4);
				if (disko) {
					inode_add_bytes(type2Clone_5, type2Clone_4);
					type2Clone_3 = btrfs_inc_extent_ref(trans, root,
							disko, diskl, 0,
							root->root_key.objectid,
							type2Clone_5->i_ino,
							new_key.offset - datao);
					BUG_ON(type2Clone_3);
				}
			} else if (type == BTRFS_FILE_EXTENT_INLINE) {
				u64 skip = 0;
				u64 trim = 0;
				if (off > key.offset) {
					skip = off - key.offset;
					new_key.offset += skip;
				}

				if (key.offset + type2Clone_4 > off+type2Clone_2)
					trim = key.offset + type2Clone_4 - (off+type2Clone_2);

				if (comp && (skip || trim)) {
					type2Clone_3 = -EINVAL;
					goto out;
				}
				size -= skip + trim;
				type2Clone_4 -= skip + trim;
				type2Clone_3 = btrfs_insert_empty_item(trans, root, path,
							      &new_key, size);
				if (type2Clone_3)
					goto out;

				if (skip) {
					u32 start =
					  btrfs_file_extent_calc_inline_size(0);
					memmove(buf+start, buf+start+skip,
						type2Clone_4);
				}

				leaf = path->nodes[0];
				slot = path->slots[0];
				write_extent_buffer(leaf, buf,
					    btrfs_item_ptr_offset(leaf, slot),
					    size);
				inode_add_bytes(type2Clone_5, type2Clone_4);
			}

			btrfs_mark_buffer_dirty(leaf);
		}

next:
		btrfs_release_path(root, path);
		key.offset++;
	}
	type2Clone_3 = 0;
out:
	btrfs_release_path(root, path);
	if (type2Clone_3 == 0) {
		type2Clone_5->i_mtime = type2Clone_5->i_ctime = CURRENT_TIME;
		if (destoff + olen > type2Clone_5->i_size)
			btrfs_i_size_write(type2Clone_5, destoff + olen);
		BTRFS_I(type2Clone_5)->flags = BTRFS_I(type2Clone_1)->flags;
		type2Clone_3 = btrfs_update_inode(trans, root, type2Clone_5);
	}
	btrfs_end_transaction(trans, root);
	unlock_extent(&BTRFS_I(type2Clone_1)->io_tree, off, off+type2Clone_2, GFP_NOFS);
	if (type2Clone_3)
		vmtruncate(type2Clone_5, 0);
out_unlock:
	mutex_unlock(&type2Clone_1->i_mutex);
	mutex_unlock(&type2Clone_5->i_mutex);
	vfree(buf);
	btrfs_free_path(path);
out_fput:
	fput(src_file);
out_drop_write:
	mnt_drop_write(file->f_path.mnt);
	return type2Clone_3;

}