static tvbuff_t *
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
  guint32 findex _U_,
  guint32 fcount,
  guint16 seq,
  gint offset,
  guint16 plen,
  gboolean fec _U_,
  guint16 rsk,
  guint16 rsz,
  fragment_data *fdx
)
{

  guint16 decoded_size;
  guint32 type2Clone_3;
  guint32 rx_min;
  tvbuff_t *new_tvb=NULL;

  if (fcount > MAX_FRAGMENTS) {
    if (tree)
      proto_tree_add_text(tree, tvb , 0, -1, "[Reassembly of %d type2Clone_1 not attempted]", fcount);
    return NULL;
  }

  decoded_size = fcount*plen;
  type2Clone_3 = fcount*plen/(rsk+PFT_RS_P);  /* rounded down */
  rx_min = type2Clone_3*rsk/plen;
  if(rx_min*plen<type2Clone_3*rsk)
    rx_min++;
  if (fdx)
    new_tvb = process_reassembled_data (tvb, offset, pinfo,
                                        "Reassembled DCP (ETSI)",
                                        fdx, &dcp_frag_items,
                                        NULL, tree);
  else {
    guint type2Clone_1=0;
    guint32 *got;
    fragment_data *type2Clone_5;
    fragment_data *fd_head;

    if(tree)
      proto_tree_add_text (tree, tvb, 0, -1, "want %d, got %d need %d",
                           fcount, type2Clone_1, rx_min
        );
    got = ep_alloc(fcount*sizeof(guint32));

    /* make a list of the findex (offset) numbers of the type2Clone_1 we have */
    type2Clone_5 = fragment_get(pinfo, seq, dcp_fragment_table);
    for (fd_head = type2Clone_5; fd_head != NULL; fd_head = fd_head->next) {
      if(fd_head->data) {
        got[type2Clone_1++] = fd_head->offset; /* this is the findex of the fragment */
      }
    }
    /* put a sentinel at the end */
    got[type2Clone_1++] = fcount;
    /* have we got enough for Reed Solomon to try to correct ? */
    if(type2Clone_1>=rx_min) { /* yes, in theory */
      guint i,current_findex;
      fragment_data *frag=NULL;
      guint8 *dummy_data = (guint8*) ep_alloc0 (plen);
      tvbuff_t *type2Clone_2 = tvb_new_real_data(dummy_data, plen, plen);
      /* try and decode with missing type2Clone_1 */
      if(tree)
          proto_tree_add_text (tree, tvb, 0, -1, "want %d, got %d need %d",
                               fcount, type2Clone_1, rx_min
            );
      /* fill the fragment table with empty type2Clone_1 */
      current_findex = 0;
      for(i=0; i<type2Clone_1; i++) {
        guint type2Clone_6 = got[i];
        if (type2Clone_6 > MAX_FRAGMENTS) {
          if (tree)
            proto_tree_add_text(tree, tvb , 0, -1, "[Reassembly of %d type2Clone_1 not attempted]", type2Clone_6);
          return NULL;
        }
        for(; current_findex<type2Clone_6; current_findex++) {
          frag = fragment_add_seq_check (type2Clone_2, 0, pinfo, seq,
                                         dcp_fragment_table, dcp_reassembled_table,
                                         current_findex, plen, (current_findex+1!=fcount));
        }
        current_findex++; /* skip over the fragment we have */
      }
      tvb_free(type2Clone_2);

      if(frag)
        new_tvb = process_reassembled_data (tvb, offset, pinfo,
                                            "Reassembled DCP (ETSI)",
                                            frag, &dcp_frag_items,
                                            NULL, tree);
    }
  }
  if(new_tvb) {
    gboolean decoded = TRUE;
    tvbuff_t *dtvb = NULL;
    const guint8 *type2Clone_4 = tvb_get_ptr(new_tvb, 0, -1);
    guint16 reassembled_size = tvb_length(new_tvb);
    guint8 *deinterleaved = (guint8*) g_malloc (reassembled_size);
    guint8 *output = (guint8*) g_malloc (decoded_size);
    rs_deinterleave(type2Clone_4, deinterleaved, plen, fcount);

    dtvb = tvb_new_child_real_data(tvb, deinterleaved, reassembled_size, reassembled_size);
    add_new_data_source(pinfo, dtvb, "Deinterleaved");
    tvb_set_free_cb(dtvb, g_free);

    decoded = rs_correct_data(deinterleaved, output, type2Clone_3, rsk, rsz);
    if(tree)
      proto_tree_add_boolean (tree, hf_edcp_rs_ok, tvb, offset, 2, decoded);

    new_tvb = tvb_new_child_real_data(dtvb, output, decoded_size, decoded_size);
    add_new_data_source(pinfo, new_tvb, "RS Error Corrected Data");
    tvb_set_free_cb(new_tvb, g_free);
  }
  return new_tvb;

}