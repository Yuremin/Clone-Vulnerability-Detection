static gboolean
CVE_2013_4936_VULN_IsDFP_Frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{

    guint16       u16SFCRC16;
    guint8        type2Clone_2;
    guint8        u8SFDataLength   = 255;
    int           type2Clone_1           = 0;
    guint32       u32SubStart;
    guint16       type2Clone_3;
    gint          tvb_len          = 0;
    unsigned char virtualFramebuffer[16];
    guint16       u16FrameID;

    /* the sub tvb will NOT contain the frame_id here! */
    u16FrameID = GPOINTER_TO_UINT(pinfo->private_data);

    /* try to bild a temporaray buffer for generating this CRC */
    memcpy(&virtualFramebuffer[0], pinfo->dst.data, 6);
    memcpy(&virtualFramebuffer[6], pinfo->src.data, 6);
    virtualFramebuffer[12] = 0x88;
    virtualFramebuffer[13] = 0x92;
    virtualFramebuffer[15] = (unsigned char) (u16FrameID &0xff);
    virtualFramebuffer[14] = (unsigned char) (u16FrameID>>8);
    type2Clone_3 = crc16_plain_init();
    type2Clone_3 = crc16_plain_update(type2Clone_3, &virtualFramebuffer[0], 16);
    type2Clone_3 = crc16_plain_finalize(type2Clone_3);
    /* can check this CRC only by having built a temporary data buffer out of the pinfo data */
    u16SFCRC16 = tvb_get_letohs(tvb, type2Clone_1);
    if (u16SFCRC16 != 0) /* no type2Clone_3! */
    {
        if (u16SFCRC16 != type2Clone_3)
        {
            proto_item_append_text(tree, ", no packed frame: SFCRC16 is 0x%x should be 0x%x", u16SFCRC16, type2Clone_3);
            return(FALSE);
        }
    }
    /* end of first CRC check */

    type2Clone_1 += 2;    /*Skip first type2Clone_3 */
    tvb_len = tvb_length(tvb);
    if (type2Clone_1 + 4 > tvb_len)
        return FALSE;
    if (tvb_get_letohs(tvb, type2Clone_1) == 0)
        return FALSE;   /* no valid DFP frame */
    while (1) {
        u32SubStart = type2Clone_1;

        type2Clone_2 = tvb_get_guint8(tvb, type2Clone_1);
        type2Clone_1 += 1;

        u8SFDataLength = tvb_get_guint8(tvb, type2Clone_1);
        type2Clone_1 += 1;

        if (u8SFDataLength == 0) {
            break;
        }

        type2Clone_1 += 2;

        type2Clone_1 += u8SFDataLength;
       if (type2Clone_1 > tvb_len)
           return /*TRUE; */FALSE;

        u16SFCRC16 = tvb_get_letohs(tvb, type2Clone_1);
        if (u16SFCRC16 != 0) {
            if (type2Clone_2 & 0x80) {
                type2Clone_3 = crc16_plain_tvb_offset_seed(tvb, u32SubStart, type2Clone_1-u32SubStart, 0);
                if (type2Clone_3 != u16SFCRC16) {
                    return FALSE;
                } else {
                }
            } else {
            }
        }
        type2Clone_1 += 2;
    }
    return TRUE;

}