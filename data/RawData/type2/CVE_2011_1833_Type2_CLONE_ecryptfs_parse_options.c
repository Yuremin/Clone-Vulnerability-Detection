static int CVE_2011_1833_VULN_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
{

	char *p;
	int type2Clone_3 = 0;
	int sig_set = 0;
	int cipher_name_set = 0;
	int fn_cipher_name_set = 0;
	int cipher_key_bytes;
	int cipher_key_bytes_set = 0;
	int fn_cipher_key_bytes;
	int fn_cipher_key_bytes_set = 0;
	struct ecryptfs_mount_crypt_stat *type2Clone_2 =
		&sbi->type2Clone_2;
	substring_t args[MAX_OPT_ARGS];
	int type2Clone_1;
	char *sig_src;
	char *cipher_name_dst;
	char *cipher_name_src;
	char *fn_cipher_name_dst;
	char *fn_cipher_name_src;
	char *fnek_dst;
	char *fnek_src;
	char *cipher_key_bytes_src;
	char *fn_cipher_key_bytes_src;

	if (!options) {
		type2Clone_3 = -EINVAL;
		goto out;
	}
	ecryptfs_init_mount_crypt_stat(type2Clone_2);
	while ((p = strsep(&options, ",")) != NULL) {
		if (!*p)
			continue;
		type2Clone_1 = match_token(p, tokens, args);
		switch (type2Clone_1) {
		case ecryptfs_opt_sig:
		case ecryptfs_opt_ecryptfs_sig:
			sig_src = args[0].from;
			type2Clone_3 = ecryptfs_add_global_auth_tok(type2Clone_2,
							  sig_src, 0);
			if (type2Clone_3) {
				printk(KERN_ERR "Error attempting to register "
				       "global sig; type2Clone_3 = [%d]\n", type2Clone_3);
				goto out;
			}
			sig_set = 1;
			break;
		case ecryptfs_opt_cipher:
		case ecryptfs_opt_ecryptfs_cipher:
			cipher_name_src = args[0].from;
			cipher_name_dst =
				type2Clone_2->
				global_default_cipher_name;
			strncpy(cipher_name_dst, cipher_name_src,
				ECRYPTFS_MAX_CIPHER_NAME_SIZE);
			cipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\0';
			cipher_name_set = 1;
			break;
		case ecryptfs_opt_ecryptfs_key_bytes:
			cipher_key_bytes_src = args[0].from;
			cipher_key_bytes =
				(int)simple_strtol(cipher_key_bytes_src,
						   &cipher_key_bytes_src, 0);
			type2Clone_2->global_default_cipher_key_size =
				cipher_key_bytes;
			cipher_key_bytes_set = 1;
			break;
		case ecryptfs_opt_passthrough:
			type2Clone_2->flags |=
				ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;
			break;
		case ecryptfs_opt_xattr_metadata:
			type2Clone_2->flags |=
				ECRYPTFS_XATTR_METADATA_ENABLED;
			break;
		case ecryptfs_opt_encrypted_view:
			type2Clone_2->flags |=
				ECRYPTFS_XATTR_METADATA_ENABLED;
			type2Clone_2->flags |=
				ECRYPTFS_ENCRYPTED_VIEW_ENABLED;
			break;
		case ecryptfs_opt_fnek_sig:
			fnek_src = args[0].from;
			fnek_dst =
				type2Clone_2->global_default_fnek_sig;
			strncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);
			type2Clone_2->global_default_fnek_sig[
				ECRYPTFS_SIG_SIZE_HEX] = '\0';
			type2Clone_3 = ecryptfs_add_global_auth_tok(
				type2Clone_2,
				type2Clone_2->global_default_fnek_sig,
				ECRYPTFS_AUTH_TOK_FNEK);
			if (type2Clone_3) {
				printk(KERN_ERR "Error attempting to register "
				       "global fnek sig [%s]; type2Clone_3 = [%d]\n",
				       type2Clone_2->global_default_fnek_sig,
				       type2Clone_3);
				goto out;
			}
			type2Clone_2->flags |=
				(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES
				 | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);
			break;
		case ecryptfs_opt_fn_cipher:
			fn_cipher_name_src = args[0].from;
			fn_cipher_name_dst =
				type2Clone_2->global_default_fn_cipher_name;
			strncpy(fn_cipher_name_dst, fn_cipher_name_src,
				ECRYPTFS_MAX_CIPHER_NAME_SIZE);
			type2Clone_2->global_default_fn_cipher_name[
				ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\0';
			fn_cipher_name_set = 1;
			break;
		case ecryptfs_opt_fn_cipher_key_bytes:
			fn_cipher_key_bytes_src = args[0].from;
			fn_cipher_key_bytes =
				(int)simple_strtol(fn_cipher_key_bytes_src,
						   &fn_cipher_key_bytes_src, 0);
			type2Clone_2->global_default_fn_cipher_key_bytes =
				fn_cipher_key_bytes;
			fn_cipher_key_bytes_set = 1;
			break;
		case ecryptfs_opt_unlink_sigs:
			type2Clone_2->flags |= ECRYPTFS_UNLINK_SIGS;
			break;
		case ecryptfs_opt_mount_auth_tok_only:
			type2Clone_2->flags |=
				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
			break;
		case ecryptfs_opt_err:
		default:
			printk(KERN_WARNING
			       "%s: eCryptfs: unrecognized option [%s]\n",
			       __func__, p);
		}
	}
	if (!sig_set) {
		type2Clone_3 = -EINVAL;
		ecryptfs_printk(KERN_ERR, "You must supply at least one valid "
				"auth tok signature as a mount "
				"parameter; see the eCryptfs README\n");
		goto out;
	}
	if (!cipher_name_set) {
		int cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);

		BUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);
		strcpy(type2Clone_2->global_default_cipher_name,
		       ECRYPTFS_DEFAULT_CIPHER);
	}
	if ((type2Clone_2->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)
	    && !fn_cipher_name_set)
		strcpy(type2Clone_2->global_default_fn_cipher_name,
		       type2Clone_2->global_default_cipher_name);
	if (!cipher_key_bytes_set)
		type2Clone_2->global_default_cipher_key_size = 0;
	if ((type2Clone_2->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)
	    && !fn_cipher_key_bytes_set)
		type2Clone_2->global_default_fn_cipher_key_bytes =
			type2Clone_2->global_default_cipher_key_size;
	mutex_lock(&key_tfm_list_mutex);
	if (!ecryptfs_tfm_exists(type2Clone_2->global_default_cipher_name,
				 NULL)) {
		type2Clone_3 = ecryptfs_add_new_key_tfm(
			NULL, type2Clone_2->global_default_cipher_name,
			type2Clone_2->global_default_cipher_key_size);
		if (type2Clone_3) {
			printk(KERN_ERR "Error attempting to initialize "
			       "cipher with name = [%s] and key size = [%td]; "
			       "type2Clone_3 = [%d]\n",
			       type2Clone_2->global_default_cipher_name,
			       type2Clone_2->global_default_cipher_key_size,
			       type2Clone_3);
			type2Clone_3 = -EINVAL;
			mutex_unlock(&key_tfm_list_mutex);
			goto out;
		}
	}
	if ((type2Clone_2->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)
	    && !ecryptfs_tfm_exists(
		    type2Clone_2->global_default_fn_cipher_name, NULL)) {
		type2Clone_3 = ecryptfs_add_new_key_tfm(
			NULL, type2Clone_2->global_default_fn_cipher_name,
			type2Clone_2->global_default_fn_cipher_key_bytes);
		if (type2Clone_3) {
			printk(KERN_ERR "Error attempting to initialize "
			       "cipher with name = [%s] and key size = [%td]; "
			       "type2Clone_3 = [%d]\n",
			       type2Clone_2->global_default_fn_cipher_name,
			       type2Clone_2->global_default_fn_cipher_key_bytes,
			       type2Clone_3);
			type2Clone_3 = -EINVAL;
			mutex_unlock(&key_tfm_list_mutex);
			goto out;
		}
	}
	mutex_unlock(&key_tfm_list_mutex);
	type2Clone_3 = ecryptfs_init_global_auth_toks(type2Clone_2);
	if (type2Clone_3)
		printk(KERN_WARNING "One or more global auth toks could not "
		       "properly register; type2Clone_3 = [%d]\n", type2Clone_3);
out:
	return type2Clone_3;

}