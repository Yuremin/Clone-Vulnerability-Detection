int CVE_2006_1525_VULN_inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg)
{

	struct rtattr **rta = arg;
	struct rtmsg *rtm = NLMSG_DATA(nlh);
	struct rtable *rt = NULL;
	u32 dst = 0;
	u32 src = 0;
	int type2Clone_2 = 0;
	int err = -ENOBUFS;
	struct sk_buff *type2Clone_1;

	type2Clone_1 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!type2Clone_1)
		goto out;

	/* Reserve room for dummy headers, this type2Clone_1 can pass
	   through good chunk of routing engine.
	 */
	type2Clone_1->mac.raw = type2Clone_1->data;
	skb_reserve(type2Clone_1, MAX_HEADER + sizeof(struct iphdr));

	if (rta[RTA_SRC - 1])
		memcpy(&src, RTA_DATA(rta[RTA_SRC - 1]), 4);
	if (rta[RTA_DST - 1])
		memcpy(&dst, RTA_DATA(rta[RTA_DST - 1]), 4);
	if (rta[RTA_IIF - 1])
		memcpy(&type2Clone_2, RTA_DATA(rta[RTA_IIF - 1]), sizeof(int));

	if (type2Clone_2) {
		struct net_device *dev = __dev_get_by_index(type2Clone_2);
		err = -ENODEV;
		if (!dev)
			goto out_free;
		type2Clone_1->protocol	= htons(ETH_P_IP);
		type2Clone_1->dev	= dev;
		local_bh_disable();
		err = ip_route_input(type2Clone_1, dst, src, rtm->rtm_tos, dev);
		local_bh_enable();
		rt = (struct rtable*)type2Clone_1->dst;
		if (!err && rt->u.dst.error)
			err = -rt->u.dst.error;
	} else {
		struct flowi fl = { .nl_u = { .ip4_u = { .daddr = dst,
							 .saddr = src,
							 .tos = rtm->rtm_tos } } };
		int type2Clone_3 = 0;
		if (rta[RTA_OIF - 1])
			memcpy(&type2Clone_3, RTA_DATA(rta[RTA_OIF - 1]), sizeof(int));
		fl.type2Clone_3 = type2Clone_3;
		err = ip_route_output_key(&rt, &fl);
	}
	if (err)
		goto out_free;

	type2Clone_1->dst = &rt->u.dst;
	if (rtm->rtm_flags & RTM_F_NOTIFY)
		rt->rt_flags |= RTCF_NOTIFY;

	NETLINK_CB(type2Clone_1).dst_pid = NETLINK_CB(in_skb).pid;

	err = rt_fill_info(type2Clone_1, NETLINK_CB(in_skb).pid, nlh->nlmsg_seq,
				RTM_NEWROUTE, 0, 0);
	if (!err)
		goto out_free;
	if (err < 0) {
		err = -EMSGSIZE;
		goto out_free;
	}

	err = netlink_unicast(rtnl, type2Clone_1, NETLINK_CB(in_skb).pid, MSG_DONTWAIT);
	if (err > 0)
		err = 0;
out:	return err;

out_free:
	kfree_skb(type2Clone_1);
	goto out;

}