import os
import re
from  antlr.main import javaparser

class function:
    parent_file = None
    parent_num_loc = None
    name = None
    lines = None
    funcId = None
    parameterlist = []  # list of parameter variables
    variablelist = []  # list of local variables
    datatypelist = []  # list of data types, including user-defined types
    funccalleelist = []  # list of called functions' names
    funcbody = None

    def __init__(self, filename):
        self.parent_file = filename
        self.parameter_list = []
        self.variable_list = []
        self.datatype_list = []
        self.funccallee_list = []



def load_directory(root_directory):

    source_file_list = []
    for root, dirs, files in os.walk(root_directory):
        for filename in files:
            if filename.endswith('.java'):
                absolute_filename = os.path.join(root, filename)
                source_file_list.append(absolute_filename)
    return source_file_list


def parsefile_shallow(source_file_name):
    function_instance_list = []
   
    function_list = javaparser(source_file_name)
    for func in function_list:
        function_instance = function(source_file_name)
        function_instance.funcbody=func["funcbody"]
        function_instance.name = func["name"]
        function_instance.parameter_list = func["parameters"]
        function_instance.variable_list = func["variables"]
        

        function_instance_list.append(function_instance)
    return function_instance_list




def parsefile_deep(source_file_name):
    function_instance_list = []
   
    function_list = javaparser(source_file_name)
    for func in function_list:
        function_instance = function(source_file_name)
        function_instance.funcbody=func["funcbody"]
        function_instance.name = func["name"]
        function_instance.parameter_list = func["parameters"]
        function_instance.variable_list = func["variables"]
        

        function_instance_list.append(function_instance)
    return function_instance_list       

def remove_comment(string):
    c_regex = re.compile(
        r'(?P<comment>//.*?$|[{}]+)|(?P<multilinecomment>/\*.*?\*/)|(?P<noncomment>\'(\\.|[^\\\'])*\'|"(\\.|[^\\"])*"|.[^/\'"]*)',
        re.DOTALL | re.MULTILINE)
    return ''.join([c.group('noncomment') for c in c_regex.finditer(string) if c.group('noncomment')])

def normalization(string):
    return ''.join(string.replace('\n', '').replace('\r', '').replace('\t', '').replace('{', '').replace('}', '').split(' ')).lower()

def abstraction(instance, level):
    original_funcbody = instance.funcbody
    original_funcbody = remove_comment(original_funcbody)
    abstract_funcbody = original_funcbody
    
    if int(level) >= 1:  # PARAM
        parameter_list = instance.parameter_list
        for param in parameter_list:
            if len(param) == 0:
                continue
            try:
                paramPattern = re.compile("(^|\W)" + param + "(\W)")
                abstract_funcbody = paramPattern.sub("\g<1>FPARAM\g<2>", abstract_funcbody)
            except:
                pass



    if int(level) >= 3:  # LVAR
        variable_list = instance.variable_list
        for lvar in variable_list:
            if len(lvar) == 0:
                continue
            try:
                lvarPattern = re.compile("(^|\W)" + lvar + "(\W)")
                abstract_funcbody = lvarPattern.sub("\g<1>LVAR\g<2>", abstract_funcbody)
            except:
                pass
    
    return (original_funcbody, abstract_funcbody)

if __name__=="__main__":
    parsefile_shallow("/home/min/Projects/Guotie/CVD/src/antlr/test/AllInOne11.java")
