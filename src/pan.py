import javaparser as jp
import cparser as cp
from hashlib import md5
import os


def pan_generation(file):
    size = os.path.getsize(file)
    c_fingerprints = []
    java_fingerprints = []
    if file.endswith(".c") or file.endswith(".cpp"):                       #for c
        cfunction_list = cp.parsefile_deep(file)
        for cfunction in cfunction_list:
            abstracted_body = cp.abstraction(cfunction, 4)[1]
            normalized_body = cp.normalization(abstracted_body)
            func_len = len(normalized_body)
            
            if func_len > 50 and "bad" in cfunction.name:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                c_fingerprints.append(hashvalue)
                with open("../fingerprint/c_fingerprint.cvd", "a") as f_finger:
                    f_finger.write(hashvalue+"===>"+cfunction.parent_file+"---"+cfunction.name+"\n")
            else:
                continue

    elif file.endswith(".java"):
        jfunction_list = jp.parsefile_deep(file)
        for jfunction in jfunction_list:
            abstracted_body = jp.abstraction(jfunction, 4)[1]
            normalized_body = jp.normalization(abstracted_body)
            func_len = len(normalized_body)

            if func_len > 50 and "bad" in jfunction.name:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                java_fingerprints.append(hashvalue)
                with open("../fingerprint/java_fingerprint.cvd", "a") as f_finger:
                    f_finger.write(hashvalue+"===>"+jfunction.parent_file+"---"+jfunction.name+"\n")
            else:
                continue

    return c_fingerprints, java_fingerprints


def pan_detection(file):
    flag_too_large = False
    size = os.path.getsize(file)
    if size > 1000000:
        flag_too_large = True
        return None,None,flag_too_large
    c_fingerprints = []
    c_functions = []
    java_fingerprints = []
    java_functions = []
    if file.endswith(".c") or file.endswith(".cpp"):                       #for c
        cfunction_list = cp.parsefile_deep(file)
        for cfunction in cfunction_list:
            abstracted_body = cp.abstraction(cfunction, 4)[1]
            normalized_body = cp.normalization(abstracted_body)
            func_len = len(normalized_body)
            
            if func_len > 50:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                c_fingerprints.append(hashvalue)
                c_functions.append(cfunction.name)
            else:
                continue

    elif file.endswith(".java"):
        jfunction_list = jp.parsefile_deep(file)
        for jfunction in jfunction_list:
            abstracted_body = jp.abstraction(jfunction, 4)[1]
            normalized_body = jp.normalization(abstracted_body)
            func_len = len(normalized_body)

            if func_len > 50:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                java_fingerprints.append(hashvalue)
                java_functions.append(jfunction.name)
            else:
                continue

    return c_fingerprints+java_fingerprints, c_functions+java_functions, flag_too_large