import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
import subprocess
import os
import sys
from tkinter import filedialog
import tqdm
from hashlib import md5
import javaparser as jp
import cparser as cp
import multiprocessing as mp
import datetime
import shutil
from auth import check
import tkinter.messagebox
import time
from get_cpu_count import get_cpu_count



def parsing_abstraction_normalization(file):
    c_fingerprints = []
    java_fingerprints = []
    if file.endswith(".c") or file.endswith(".cpp"):                       #for c
        function_list = cp.parsefile_deep(file)
        for function in function_list:
            path = function.parent_file
            abstracted_body = cp.abstraction(function, 4)[1]
            normalized_body = cp.normalization(abstracted_body)
            func_len = len(normalized_body)
            
            if func_len > 50:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                c_fingerprints.append(hashvalue)
            else:
                continue

    elif file.endswith(".java"):
        function_list = jp.parsefile_deep(file)
        for function in function_list:
            path = function.parent_file
            abstracted_body = jp.abstraction(function, 4)[1]
            normalized_body = jp.normalization(abstracted_body)
            func_len = len(normalized_body)

            if func_len > 50:
                hashvalue = md5(normalized_body.encode()).hexdigest()
                java_fingerprints.append(hashvalue)
            else:
                continue

    return c_fingerprints, java_fingerprints




               



class LCVDScreen(tk.Tk):
    def __init__(self):
        super().__init__()
        self.path_generation = ""
        self.path_detection = ""
        self.vulnerability_management_flag = 0
       
        self.title("LCVD漏洞检测系统")
        #self.geometry("800x600")
        self.resizable(False, False)
        
        self.menubar = ttk.Menu(self, tearoff=0)
        self.menubar.add_command(label="帮助", command=self.show_help)
        self.menubar.add_command(label="关于", command=self.show_help)
        self.menubar.add_command(label="漏洞程序代码数据管理", command=self.vulnerability_management)
        self.config(menu=self.menubar)
        
        style = ttk.Style()
        style.configure("my.TButton", font=("黑体", 12))

        self.top_frame = ttk.Frame(self,
                                   bootstyle="secondary",
                                    )
        self.top_frame.pack(fill=tk.BOTH)
        self.top_separator_bottom = ttk.Separator(bootstyle="primary").pack(fill=tk.X)
        self.bottom_frame = ttk.Frame(self,
                                      bootstyle="secondary")
        self.bottom_frame.pack(fill=tk.BOTH, expand=True)   
#=========================================================================================
#=====================================top frame===========================================
#=========================================================================================
        #====================Button dataloader1====================
        self.button_dataloader1 = ttk.Button(
                self.top_frame,
                text="加载文件夹",
                command=self.select_directory1,
                width=10,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader1.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader1 = ttk.Entry(self.top_frame)
        self.show_dataloader1.grid(row=0, column=1, sticky=W)

        #========================Button generator================
        self.button_generator = ttk.Button(
                self.top_frame,
                text="生成指纹",
                command=self.generator,
                width=10,
                style="my.TButton",
                )
        self.button_generator.grid(row=0, column=2, padx=5, pady=10)
        scrollbar1 = tk.Scrollbar(self.top_frame)
        scrollbar1.grid(row=1, column=2, sticky=NS)
        self.generator_process = tk.Listbox(self.top_frame,
                                            height=10,
                                            width=95,
                                            bg="yellow",
                                            yscrollcommand=scrollbar1.set)
        self.generator_process.grid(row=1, column=0, columnspan=3)
        scrollbar1.config(command=self.generator_process.yview)

#=============================================================================================
#=========================bottom frame========================================================
#=============================================================================================
        #=======================Button dataloader2======================
        self.button_dataloader2 = ttk.Button(
                self.bottom_frame,
                text="选择待测文件夹",
                command=self.select_directory2,
                width=15,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader2.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader2 = ttk.Entry(self.bottom_frame)
        self.show_dataloader2.grid(row=0, column=1, sticky=W)

        #=======================Button detector========================
        self.button_detector = ttk.Button(
                self.bottom_frame,
                text="开始检测",
                command=self.detector,
                width=10,
                style="my.TButton")
        self.button_detector.grid(row=0, column=2, padx=5, pady=10)
        scrollbar2 = tk.Scrollbar(self.bottom_frame)
        scrollbar2.grid(row=1, column=2, sticky=NS)
        self.detector_process = tk.Listbox(self.bottom_frame,
                                           height=10,
                                           width=95,
                                           bg="yellow",
                                           yscrollcommand=scrollbar2.set,
                                           )
        self.detector_process.grid(row=1, column=0, columnspan=3)
        scrollbar2.config(command=self.detector_process.yview)


        #===========================
        #===============================
        #===============================
        self.button_resultfolder = ttk.Button(self.bottom_frame,
                                            text="结果文件夹", 
                                            command=self.open_folder, 
                                            width=10,
                                            style="my.TButton",
                                            bootstyle="info")
        self.button_resultfolder.grid(row=2,column=0,sticky=E,pady=5)


    def show_help(self):
        pass


    def moveScroll(self, event):
        if event.delta < 0:
            self.deal_line(self.op)

    def vulnerability_management(self):
        if self.vulnerability_management_flag == 1:
            return
        else:
            self.vulnerability_management_flag += 1
        

        self.tl = tk.Toplevel()
        self.tl.title("漏洞程序代码数据管理")

        scrollbar = tk.Scrollbar(self.tl, command= self.moveScroll)
        scrollbar.bind("<MouseWheel>", self.moveScroll)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
       
        title = ['1','2','3','4','5']
        self.box = ttk.Treeview(self.tl, columns=title,
                                yscrollcommand=scrollbar.set,
                                show='headings')
        self.box.bind("<MouseWheel>",self.moveScroll)
        
        self.box.column('1',width=50,anchor='center')
        self.box.column('2',width=250,anchor='center')
        self.box.column('3',width=300,anchor='center')
        self.box.column('4',width=500,anchor='center')

        self.box.heading('1',text='序号')
        self.box.heading('2',text='漏洞类型')
        self.box.heading('3',text='文件名')
        self.box.heading('4',text='文件路径')

        self.op  = self.read_vul_data()
        self.deal_line(self.op)

        scrollbar.config(command = self.box.yview) 
        self.box.pack()
        self.vulnerability_management_flag -= 1

        button_add_vul_file = ttk.Button(self.tl,
                                    text="添加漏洞文件",
                                    command=self.add_vul_file).pack(side=tk.LEFT, padx=140)
        button_remove_vul_file = ttk.Button(self.tl,
                                    text="删除漏洞文件",
                                    command=self.remove_vul_file).pack(side=tk.LEFT, padx=10)
        button_refresh_vul_file = ttk.Button(self.tl,
                                             text="刷新文件",
                                             command=self.refresh_vul_file).pack(side=tk.LEFT, padx=140)



    def add_vul_file(self):
        self.tl.destroy()
        self.vulnerability_management_flag += 1
        selected_file = filedialog.askopenfilename()
        if selected_file.endswith(".java") or selected_file.endswith(".c") or selected_file.endswith(".cpp"):
            pass
        else:
            tk.messagebox.showinfo(title='LCVD', message='No c/java file.')
            return 0

        os.system("cp "+f'"{selected_file}"'+' ../vul_management/data/common/')
        

        
        i = '../vul_management/data/common/'+selected_file.split('/')[-1]
        info = ""
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            num = len(f.readlines())

        with open('../vul_management/vulnerability_management.txt', 'a+', encoding='utf-8') as f:
            info = str(num)+', '

            vul_kind = i.split('/')[-1].split('.java')[0]
            if "CWE" in vul_kind:
                pass
            else:
                vul_kind = "其他"
            info += vul_kind+', '

            info += i.split('/')[-1]+', '
            current_path = os.path.abspath(__file__)
            father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
            grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

            path = i.replace('../', grandfather_path+'/')
            info += path+'\n'
       
            f.write(info)
        self.vulnerability_management_flag -= 1
        self.vulnerability_management()
        #self.box.insert('','end',values=[i for i in info.split(', ')])
 


    def remove_vul_file(self):
        item = self.box.selection()[0]
        Temp_student_list = self.box.item(item, "values")
        try:
            os.remove(Temp_student_list[3].strip())
            print("Deletion success")
            new_centent = []
            with open("../vul_management/vulnerability_management.txt", "r", encoding='utf-8') as f:
                for num, i in enumerate(f.readlines()):
                    if num == int(Temp_student_list[0]):
                        pass
                    else:
                        new_centent.append(i)
            with open('../vul_management/vulnerability_management.txt', 'w', encoding='utf-8') as f:
                for i in new_centent:
                    f.write(i)
        except:
            print("None chosen")
        self.tl.destroy()
        self.vulnerability_management()

    def refresh_vul_file(self):
        self.tl.destroy()
        java_list = jp.load_directory_new('../vul_management/data')
        with open('../vul_management/vulnerability_management.txt', 'w', encoding='utf-8') as f:
            for num,i in enumerate(java_list):
                f.write(str(num)+', ')

                vul_kind = i.split('/')[-1].split('.java')[0]
                if "CWE" in vul_kind:
                    pass
                else:
                    vul_kind = "其他"
                f.write(vul_kind+', ')

                f.write(i.split('/')[-1]+', ')
                current_path = os.path.abspath(__file__)
                father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
                grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

                path = i.replace('../', grandfather_path+'/')
                f.write(path+'\n')

        self.vulnerability_management()
 


    def read_vul_data(self):
        java_list = jp.load_directory_new('../vul_management/data')
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            line = f.readline()
            while line:
                yield line
                line = f.readline()
    def deal_line(self, op):
        while 1:
            try:
                line = next(op)
            except StopIteration:
                break
            else:
                self.box.insert('','end',values=[i for i in line.split(', ')])
                


    def select_directory1(self):
        selected_directory = filedialog.askdirectory()
        self.path_generation = selected_directory
        self.show_dataloader1.delete(0,END)
        self.show_dataloader1.insert(0,selected_directory)
    def select_directory2(self):
        selected_directory = filedialog.askdirectory()
        self.path_detection = selected_directory
        self.show_dataloader2.delete(0,END)
        self.show_dataloader2.insert(0,selected_directory)

         
    def open_folder(self):
        subprocess.Popen(
                ["xdg-open", os.path.join(os.getcwd(),"../temp")],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
                )
    def generator(self):
        print("="*50)
        print("开始加载数据")
        cfilelist = cp.load_directory_new(self.path_generation)
        javafilelist = jp.load_directory_new(self.path_generation)
        num_cfile = len(cfilelist)
        num_javafile = len(javafilelist)
        if num_cfile + num_javafile == 0:
            tk.messagebox.showinfo(title='LCVD', message='文件夹里没有C/C++/Java源代码文件，请重新选择')
            return 0
        else:
            print(f"此次检测共有{num_cfile+num_javafile}个文件")
        print("="*50)
        print("开始生成指纹")
        generation_start_time = time.time()
        old_progress = -1
        for idx, function_list in enumerate(pool.imap_unordered(parsing_abstraction_normalization, cfilelist+javafilelist)):
            progress = int(idx//((num_cfile+num_javafile)/100))
            finish = int(progress/2)*"*"
            need_do = "-" * int(50 - progress/2)
            dur = time.time()-generation_start_time
            if progress == 0 and progress > old_progress:
                print("进度: \r{:^3.0f}%[{}->{}]{:.2f}s".format(progress, finish, need_do, dur))
                old_progress = progress
            elif progress > old_progress:
                print("进度: \r{:^3.0f}%[{}->{}]{:.2f}s".format(progress, finish, need_do, dur))
                old_progress = progress

            c_hashvalues,java_hashvalues = function_list
            for i in c_hashvalues:
                self.generator_process.insert(END, c_hashvalues)
            with open("../fingerprint/java_fingerprint.cvd", "a") as f_finger:
                f_finger.write(hashvalue+"===>"+path+"---"+f.name+"\n")

                else:
                    self.generator_process.insert(END, f"The function {f.name} is too short.")

        tk.messagebox.showinfo(title='LCVD', message='脆弱性指纹生成完成')

    def detector(self):
        contents = []
        try:
            with open("../fingerprint/java_fingerprint.cvd") as f:
                contents = f.readlines()
        except Exception as e:
            print(e)
            print("No java fingerprints")
        try:
            with open("../fingerprint/C_fingerprint.cvd") as f:
                contents += f.readlines()
        except Exception as e:
            print(e)
            print("No c fingerprints")
        vul_fingerprint = [content.strip().split("===>")[0] for content in contents]
        temp_fingerprints = []

        cfilelist = cp.load_directory_new(self.path_detection)
        javafilelist = jp.load_directory_new(self.path_detection)
        progress_num = 0
        progress_num_all = len(cfilelist+javafilelist)
        progress_flag = -1
        progress_start = time.time()
        vulnerability_num = 0

        num_cfile = len(cfilelist)
        num_javafile = len(javafilelist)
        num_vul = 0
        if num_cfile + num_javafile == 0:
            tk.messagebox.showinfo(title='LCVD', message='此文件夹中没有发现C/C++/JAVA源代码文件，请重新选择。')
            return 0
        else:
            print(f"此次检测共有{num_cfile+num_javafile}个文件")

        if not os.path.exists("../temp"):
            os.mkdir("../temp")
        
        result_file_name = f"../temp/report-{datetime.datetime.now()}"
        logging_file_name = f"../logging/log{datetime.datetime.now()}"
        logging_file = open(logging_file_name, "w")
        toolargefile = []
        parseerrorfile = []
        namingerrorfile = []

        
        if num_cfile == 0 and num_javafile == 0:
            self.detector_process.insert(END, "[-] Error: Failed to load source files")
            self.detector_process.insert(END, "    Check if you selected the proper directory, or if your project contains .c, .cpp, .java files")
            return 0
        #for file in cfilelist[210400:210500]:
        for file in cfilelist:
            size = os.path.getsize(file)
            try:
                logging_file.write(file+"\n")
            except:
                namingerrorfile.append(str(file).encode("utf-8","replace").decode())
                progress_num += 1
                continue
            progress_num += 1
            if progress_num_all >100: 
                progress = progress_num//(progress_num_all//100)
                if progress > progress_flag:
                    progress_flag = progress
                    print("进度: {}% ".format(progress),"*"*(progress//2))
                    if progress > 0:
                        print("预计时间: {}min".format((progress_num_all-progress_num)/progress_num*(time.time()-progress_start)/60))
                        self.detector_process.delete(30,END)
            
            self.detector_process.update()
            if size > 1000000:
                toolargefile.append(file)
                self.detector_process.insert(0, f"File is too large")
                continue
 
            function_instance_list = cp.parsefile_deep(file)

            for f in function_instance_list:
                path = f.parent_file
                abstract_body = cp.abstraction(f, 4)[1]
                abstract_body = cp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50:
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.detector_process.insert(0, hashvalue)
                    for vul in vul_fingerprint:
                        if hashvalue == vul:
                            with open(result_file_name, "a") as result_file:
                                num_vul += 1
                                result_file.write(f"{path}------{f.name}存在克隆漏洞风险\n")
                            break

                else:
                    self.detector_process.insert(0, f"Function {f.name} is too short.")
        for file in javafilelist:
            try:
                logging_file.write(file+"\n")
            except:
                namingerrorfile.append(str(file).encode("utf-8","replace").decode())
                progress_num += 1
                continue
            progress_num += 1
            if progress_num_all >100: 
                progress = progress_num//(progress_num_all//100)
                if progress > progress_flag:
                    progress_flag = progress
                    print("进度: {}% ".format(progress),"*"*(progress//2), end="")
                    if progress > 0:
                        print("预计时间: {}min".format((progress_num_all-progress_num)/progress_num*(time.time()-progress_start)/60))
                        self.detector_process.delete(30,END)
 
            self.detector_process.update()
            try:
                function_instance_list = jp.parsefile_deep(file)
            except:
                parseerrorfile.append(file)
            for f in function_instance_list:
                path = f.parent_file
                abstract_body = jp.abstraction(f, 4)[1]
                abstract_body = jp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50:
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.detector_process.insert(0, hashvalue)
                    for vul in vul_fingerprint:
                        if hashvalue == vul:
                            with open(result_file_name, "a") as result_file:
                                num_vul += 1
                                result_file.write(f"{path}------{f.name}存在克隆漏洞风险\n")
                            break
                else:
                    self.detector_process.insert(0, f"The {path} 's function {f.name} is too short.")
            
        if os.path.exists(result_file_name):
            with open(result_file_name, "r") as result_file:
                contents_old = result_file.read()
        else:
            contents_old = ""
        with open(result_file_name, "w") as result_file:
            result_file.write(f"======本次检测一共包含{num_cfile+num_javafile}个文件，其中c语言文件为{num_cfile}个，Java语言文件为{num_javafile}个，检测出漏洞文件{num_vul}个======\n\n"+contents_old)
            if len(toolargefile) > 0 or len(parseerrorfile):
                result_file.write(f"\n\n======以下文件无法成功进行检测======\n")
                if len(toolargefile) > 0:
                    result_file.write(f"{len(toolargefile)}文件过大，不符合编程规范，建议重新拆分后检测，文件名如下：\n")
                    for file in toolargefile:
                        result_file.write(file+"\n")
                if len(parseerrorfile) > 0:
                    result_file.write(f"{len(parseerrorfile)}文件过大，不符合编程规范，建议重新拆分后检测，文件名如下：\n")
                    for file in toolargefile:
                        result_file.write(file+"\n")
                if len(namingerrorfile) > 0:
                    result_file.write(f"{len(parseerrorfile)}文件名编码错误，请重新命名，文件名如下：\n")
                    for file in namingerrorfile:
                        result_file.write(file+"\n")



                
        tk.messagebox.showinfo(title='LCVD', message=f'比对完成，检测结果见{result_file_name}')


def main():
    #check()
    screen = LCVDScreen()
    screen.mainloop()


if __name__=="__main__":
    cpu_count = get_cpu_count()
    pool = mp.Pool(processes = cpu_count-1)
    main()