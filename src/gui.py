import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
import subprocess
import os
import sys
from tkinter import filedialog
import tqdm
from hashlib import md5
import javaparser as jp
import cparser as cp
import multiprocessing as mp
import datetime
import shutil
from auth import check
import tkinter.messagebox




class LCVDScreen(tk.Tk):
    def __init__(self):
        super().__init__()
        self.path_generation = ""
        self.path_detection = ""
       
        self.title("LCVD漏洞检测系统")
        #self.geometry("800x600")
        self.resizable(False, False)
        
        self.menubar = ttk.Menu(self, tearoff=0)
        self.menubar.add_command(label="帮助", command=self.show_help)
        self.menubar.add_command(label="关于", command=self.show_help)
        self.menubar.add_command(label="漏洞程序代码数据管理", command=self.vulnerability_management)
        self.config(menu=self.menubar)
        
        style = ttk.Style()
        style.configure("my.TButton", font=("黑体", 12))

        self.top_frame = ttk.Frame(self,
                                   bootstyle="secondary",
                                    )
        self.top_frame.pack(fill=tk.BOTH)
        self.top_separator_bottom = ttk.Separator(bootstyle="primary").pack(fill=tk.X)
        self.bottom_frame = ttk.Frame(self,
                                      bootstyle="secondary")
        self.bottom_frame.pack(fill=tk.BOTH, expand=True)   
#=========================================================================================
#=====================================top frame===========================================
#=========================================================================================
        #====================Button dataloader1====================
        self.button_dataloader1 = ttk.Button(
                self.top_frame,
                text="加载文件夹",
                command=self.select_directory1,
                width=10,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader1.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader1 = ttk.Entry(self.top_frame)
        self.show_dataloader1.grid(row=0, column=1, sticky=W)

        #========================Button generator================
        self.button_generator = ttk.Button(
                self.top_frame,
                text="生成指纹",
                command=self.generator,
                width=10,
                style="my.TButton",
                )
        self.button_generator.grid(row=0, column=2, padx=5, pady=10)
        scrollbar1 = tk.Scrollbar(self.top_frame)
        scrollbar1.grid(row=1, column=2, sticky=NS)
        self.generator_process = tk.Listbox(self.top_frame,
                                            height=10,
                                            width=95,
                                            bg="yellow",
                                            yscrollcommand=scrollbar1.set)
        self.generator_process.grid(row=1, column=0, columnspan=3)
        scrollbar1.config(command=self.generator_process.yview)

#=============================================================================================
#=========================bottom frame========================================================
#=============================================================================================
        #=======================Button dataloader2======================
        self.button_dataloader2 = ttk.Button(
                self.bottom_frame,
                text="选择待测文件夹",
                command=self.select_directory2,
                width=15,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader2.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader2 = ttk.Entry(self.bottom_frame)
        self.show_dataloader2.grid(row=0, column=1, sticky=W)

        #=======================Button detector========================
        self.button_detector = ttk.Button(
                self.bottom_frame,
                text="开始检测",
                command=self.detector,
                width=10,
                style="my.TButton")
        self.button_detector.grid(row=0, column=2, padx=5, pady=10)
        scrollbar2 = tk.Scrollbar(self.bottom_frame)
        scrollbar2.grid(row=1, column=2, sticky=NS)
        self.detector_process = tk.Listbox(self.bottom_frame,
                                           height=10,
                                           width=95,
                                           bg="yellow",
                                           yscrollcommand=scrollbar2.set,
                                           )
        self.detector_process.grid(row=1, column=0, columnspan=3)
        scrollbar2.config(command=self.detector_process.yview)


        #===========================
        #===============================
        #===============================
        self.button_resultfolder = ttk.Button(self.bottom_frame,
                                            text="结果文件夹", 
                                            command=self.open_folder, 
                                            width=10,
                                            style="my.TButton",
                                            bootstyle="info")
        self.button_resultfolder.grid(row=2,column=0,sticky=E,pady=5)


    def show_help(self):
        pass


    def moveScroll(self, event):
        if event.delta < 0:
            self.deal_line(self.op)

    def vulnerability_management(self):

        self.tl = tk.Toplevel()
        self.tl.title("漏洞程序代码数据管理")

        scrollbar = tk.Scrollbar(self.tl, command= self.moveScroll)
        scrollbar.bind("<MouseWheel>", self.moveScroll)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
       
        title = ['1','2','3','4','5']
        self.box = ttk.Treeview(self.tl, columns=title,
                                yscrollcommand=scrollbar.set,
                                show='headings')
        self.box.bind("<MouseWheel>",self.moveScroll)
        
        self.box.column('1',width=50,anchor='center')
        self.box.column('2',width=250,anchor='center')
        self.box.column('3',width=300,anchor='center')
        self.box.column('4',width=500,anchor='center')

        self.box.heading('1',text='序号')
        self.box.heading('2',text='漏洞类型')
        self.box.heading('3',text='文件名')
        self.box.heading('4',text='文件路径')

        self.op  = self.read_data()
        self.deal_line(self.op)

        scrollbar.config(command = self.box.yview) 
        self.box.pack()

        button_add_file = ttk.Button(self.tl,
                                    text="添加漏洞文件",
                                    command=self.add_file).pack(side=tk.LEFT, padx=140)
        button_remove_file = ttk.Button(self.tl,
                                    text="删除漏洞文件",
                                    command=self.remove_file).pack(side=tk.LEFT, padx=10)



    def add_file(self):
        self.tl.destroy()
        selected_file = filedialog.askopenfilename()
        if selected_file.endswith(".java") or selected_file.endswith(".c") or selected_file.endswith(".cpp"):
            pass
        else:
            tk.messagebox.showinfo(title='LCVD', message='No c/java file.')


        self.vulnerability_management()
        os.system("cp "+selected_file+' ../vul_management/data/common/')
        i = '../vul_management/data/common/'+selected_file.split('/')[-1]
        info = ""
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            num = len(f.readlines())

        with open('../vul_management/vulnerability_management.txt', 'a+', encoding='utf-8') as f:
            info = str(num)+', '

            vul_kind = i.split('/')[-1].split('.java')[0]
            if "CWE" in vul_kind:
                pass
            else:
                vul_kind = "其他"
            info += vul_kind+', '

            info += i.split('/')[-1]+', '
            current_path = os.path.abspath(__file__)
            father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
            grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

            path = i.replace('../', grandfather_path+'/')
            info += path+'\n'
       
            f.write(info)
        self.box.insert('','end',values=[i for i in info.split(', ')])
 


    def remove_file(self):
        item = self.box.selection()[0]
        Temp_student_list = self.box.item(item, "values")
        try:
            os.remove(Temp_student_list[3].strip())
            print("Deletion success")
        except:
            print("None chosen")
        self.tl.destroy()
        self.vulnerability_management()




    def read_data(self):

        java_list = jp.load_directory_new('../vul_management/data')
        with open('../vul_management/vulnerability_management.txt', 'w', encoding='utf-8') as f:
            for num,i in enumerate(java_list):
                f.write(str(num)+', ')

                vul_kind = i.split('/')[-1].split('.java')[0]
                if "CWE" in vul_kind:
                    pass
                else:
                    vul_kind = "其他"
                f.write(vul_kind+', ')

                f.write(i.split('/')[-1]+', ')
                current_path = os.path.abspath(__file__)
                father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
                grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

                path = i.replace('../', grandfather_path+'/')
                f.write(path+'\n')
        
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            line = f.readline()
            while line:
                yield line
                line = f.readline()
    def deal_line(self, op):
        while 1:
            try:
                line = next(op)
            except StopIteration:
                break
            else:
                self.box.insert('','end',values=[i for i in line.split(', ')])
                


    def select_directory1(self):
        selected_directory = filedialog.askdirectory()
        self.path_generation = selected_directory
        self.show_dataloader1.delete(0,END)
        self.show_dataloader1.insert(0,selected_directory)
    def select_directory2(self):
        selected_directory = filedialog.askdirectory()
        self.path_detection = selected_directory
        cfile = cp.load_directory_new(self.path_detection)
        javafile = jp.load_directory_new(self.path_detection)
        if len(cfile)+len(javafile) == 0:
            tk.messagebox.showinfo(title='LCVD', message='此文件夹中没有发现C/C++/JAVA源代码文件，请重新选择。')
            self.show_dataloader2.delete(0,END)
        else:
            self.show_dataloader2.delete(0,END)
            self.show_dataloader2.insert(0,selected_directory)
         
    def open_folder(self):
        subprocess.Popen(
                ["xdg-open", os.path.join(os.getcwd(),"../temp")],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
                )
    def generator(self):
        cfilelist = cp.load_directory_new(self.path_generation)
        javafilelist = jp.load_directory_new(self.path_generation)
        num_cfile = len(cfilelist)
        num_javafile = len(javafilelist)
        
        if num_cfile == 0 and num_javafile == 0:
            tk.messagebox.showinfo(title='LCVD', message='Failed to load source files. Check if you selected the proper directory, or if your project contains .c, .cpp, .java.')
            return 0

        for file in cfilelist:
            self.generator_process.update()
            function_instance_list = cp.parsefile_deep(file)

            for f in function_instance_list:
                path = f.parent_file
                abstract_body = cp.abstraction(f, 4)[1]
                abstract_body = cp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50 and f.name=="bad":
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.generator_process.insert(END, hashvalue)
                    with open("../fingerprint/C_fingerprint.cvd", "a") as f:
                        f.write(hashvalue+"\n")

                else:
                    self.generator_process.insert(END, f"The {path} 's function {f.name} is too short.")
 
        for file in javafilelist:
            self.generator_process.update()
            try:
                function_instance_list = jp.parsefile_deep(file)
            except:
                continue

            for f in function_instance_list:
                path = f.parent_file
                abstract_body = jp.abstraction(f, 4)[1]
                abstract_body = jp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50 and f.name=="bad":
                #if func_len > 50:
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.generator_process.insert(END, hashvalue)
                    with open("../fingerprint/java_fingerprint.cvd", "a") as f_finger:
                        f_finger.write(hashvalue+"===>"+path+"---"+f.name+"\n")

                else:
                    self.generator_process.insert(END, f"The function {f.name} is too short.")

        tk.messagebox.showinfo(title='LCVD', message='脆弱性指纹生成完成')

    def detector(self):
        try:
            with open("../fingerprint/java_fingerprint.cvd") as f:
                contents = f.readlines()
            with open("../fingerprint/C_fingerprint.cvd") as f:
                contents += f.readlines()
        except:
            pass
        vul_fingerprint = [content.strip().split("===>")[0] for content in contents]
        temp_fingerprints = []

        cfilelist = cp.load_directory_new(self.path_detection)
        javafilelist = jp.load_directory_new(self.path_detection)

        num_cfile = len(cfilelist)
        num_javafile = len(javafilelist)

        if not os.path.exists("../temp"):
            os.mkdir("../temp")
        
        result_file_name = f"../temp/report-{datetime.datetime.now()}"
        result_file = open(result_file_name, "w")

        
        if num_cfile == 0 and num_javafile == 0:
            self.detector_process.insert(END, "[-] Error: Failed to load source files")
            self.detector_process.insert(END, "    Check if you selected the proper directory, or if your project contains .c, .cpp, .java files")

        for file in cfilelist:
            self.detector_process.update()
            function_instance_list = cp.parsefile_deep(file)

            for f in function_instance_list:
                path = f.parent_file
                abstract_body = cp.abstraction(f, 4)[1]
                abstract_body = cp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50:
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.detector_process.insert(END, hashvalue)
                    for vul in vul_fingerprint:
                        if hashvalue == vul:
                            result_file.write(f"{path}------{f.name}\n")
                            break

                else:
                    self.detector_process.insert(END, f"The {path} 's function {f.name} is too short.")
 
        for file in javafilelist:
            self.detector_process.update()
            try:
                function_instance_list = jp.parsefile_deep(file)
            except:
                continue
            for f in function_instance_list:
                path = f.parent_file
                abstract_body = jp.abstraction(f, 4)[1]
                abstract_body = jp.normalization(abstract_body)
                func_len = len(abstract_body)
            
                if func_len > 50:
                    hashvalue = md5(abstract_body.encode()).hexdigest()
                    self.detector_process.insert(END, hashvalue)
                    for vul in vul_fingerprint:
                        if hashvalue == vul:
                            result_file.write(f"{path}------{f.name}存在克隆漏洞风险\n")
                            break
 

                else:
                    self.detector_process.insert(END, f"The {path} 's function {f.name} is too short.")

       

        tk.messagebox.showinfo(title='LCVD', message=f'比对完成，检测结果见{result_file_name}')
        result_file.close()

 



if __name__=="__main__":
    check()
    screen = LCVDScreen()
    screen.mainloop()
