import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
import subprocess
import os
from tkinter import filedialog
import multiprocessing as mp
import datetime
from auth import check
import time
from get_cpu_count import get_cpu_count
from pan import pan_generation, pan_detection
import javaparser as jp
import cparser as cp


               



class LCVDScreen(tk.Tk):
    def __init__(self):
        super().__init__()
        self.path_generation = ""
        self.path_detection = ""
        self.vulnerability_management_flag = 0
       
        self.title("LCVD漏洞检测系统")
        #self.geometry("800x600")
        self.resizable(False, False)
        
        self.menubar = ttk.Menu(self, tearoff=0)
        self.menubar.add_command(label="帮助", command=self.show_help)
        self.menubar.add_command(label="关于", command=self.show_help)
        self.menubar.add_command(label="漏洞程序代码数据管理", command=self.vulnerability_management)
        self.config(menu=self.menubar)
        
        style = ttk.Style()
        style.configure("my.TButton", font=("黑体", 12))

        self.top_frame = ttk.Frame(self,
                                   bootstyle="secondary",
                                    )
        self.top_frame.pack(fill=tk.BOTH)
        self.top_separator_bottom = ttk.Separator(bootstyle="primary").pack(fill=tk.X)
        self.bottom_frame = ttk.Frame(self,
                                      bootstyle="secondary")
        self.bottom_frame.pack(fill=tk.BOTH, expand=True)   
#=========================================================================================
#=====================================top frame===========================================
#=========================================================================================
        #====================Button dataloader1====================
        self.button_dataloader1 = ttk.Button(
                self.top_frame,
                text="加载文件夹",
                command=self.select_directory1,
                width=10,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader1.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader1 = ttk.Entry(self.top_frame)
        self.show_dataloader1.grid(row=0, column=1, sticky=W)

        #========================Button generator================
        self.button_generator = ttk.Button(
                self.top_frame,
                text="生成指纹",
                command=self.generator,
                width=10,
                style="my.TButton",
                )
        self.button_generator.grid(row=0, column=2, padx=5, pady=10)
        scrollbar1 = tk.Scrollbar(self.top_frame)
        scrollbar1.grid(row=1, column=2, sticky=NS)
        self.generator_process = tk.Listbox(self.top_frame,
                                            height=10,
                                            width=95,
                                            bg="yellow",
                                            yscrollcommand=scrollbar1.set)
        self.generator_process.grid(row=1, column=0, columnspan=3)
        scrollbar1.config(command=self.generator_process.yview)

#=============================================================================================
#=========================bottom frame========================================================
#=============================================================================================
        #=======================Button dataloader2======================
        self.button_dataloader2 = ttk.Button(
                self.bottom_frame,
                text="选择待测文件夹",
                command=self.select_directory2,
                width=15,
                style="my.TButton",
                bootstyle="info")
        self.button_dataloader2.grid(row=0, column=0, pady=10, sticky=E)
        self.show_dataloader2 = ttk.Entry(self.bottom_frame)
        self.show_dataloader2.grid(row=0, column=1, sticky=W)

        #=======================Button detector========================
        self.button_detector = ttk.Button(
                self.bottom_frame,
                text="开始检测",
                command=self.detector,
                width=10,
                style="my.TButton")
        self.button_detector.grid(row=0, column=2, padx=5, pady=10)
        scrollbar2 = tk.Scrollbar(self.bottom_frame)
        scrollbar2.grid(row=1, column=2, sticky=NS)
        self.detector_process = tk.Listbox(self.bottom_frame,
                                           height=10,
                                           width=95,
                                           bg="yellow",
                                           yscrollcommand=scrollbar2.set,
                                           )
        self.detector_process.grid(row=1, column=0, columnspan=3)
        scrollbar2.config(command=self.detector_process.yview)


        #===========================
        #===============================
        #===============================
        self.button_resultfolder = ttk.Button(self.bottom_frame,
                                            text="结果文件夹", 
                                            command=self.open_folder, 
                                            width=10,
                                            style="my.TButton",
                                            bootstyle="info")
        self.button_resultfolder.grid(row=2,column=0,sticky=E,pady=5)


    def show_help(self):
        pass


    def moveScroll(self, event):
        if event.delta < 0:
            self.deal_line(self.op)

    def vulnerability_management(self):
        if self.vulnerability_management_flag == 1:
            return
        else:
            self.vulnerability_management_flag += 1
        

        self.tl = tk.Toplevel()
        self.tl.title("漏洞程序代码数据管理")

        scrollbar = tk.Scrollbar(self.tl, command= self.moveScroll)
        scrollbar.bind("<MouseWheel>", self.moveScroll)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
       
        title = ['1','2','3','4','5']
        self.box = ttk.Treeview(self.tl, columns=title,
                                yscrollcommand=scrollbar.set,
                                show='headings')
        self.box.bind("<MouseWheel>",self.moveScroll)
        
        self.box.column('1',width=50,anchor='center')
        self.box.column('2',width=250,anchor='center')
        self.box.column('3',width=300,anchor='center')
        self.box.column('4',width=500,anchor='center')

        self.box.heading('1',text='序号')
        self.box.heading('2',text='漏洞类型')
        self.box.heading('3',text='文件名')
        self.box.heading('4',text='文件路径')

        self.op  = self.read_vul_data()
        self.deal_line(self.op)

        scrollbar.config(command = self.box.yview) 
        self.box.pack()
        self.vulnerability_management_flag -= 1

        button_add_vul_file = ttk.Button(self.tl,
                                    text="添加漏洞文件",
                                    command=self.add_vul_file).pack(side=tk.LEFT, padx=140)
        button_remove_vul_file = ttk.Button(self.tl,
                                    text="删除漏洞文件",
                                    command=self.remove_vul_file).pack(side=tk.LEFT, padx=10)
        button_refresh_vul_file = ttk.Button(self.tl,
                                             text="刷新文件",
                                             command=self.refresh_vul_file).pack(side=tk.LEFT, padx=140)



    def add_vul_file(self):
        self.tl.destroy()
        self.vulnerability_management_flag += 1
        selected_file = filedialog.askopenfilename()
        if selected_file.endswith(".java") or selected_file.endswith(".c") or selected_file.endswith(".cpp"):
            pass
        else:
            tk.messagebox.showinfo(title='LCVD', message='No c/java file.')
            return 0

        os.system("cp "+f'"{selected_file}"'+' ../vul_management/data/common/')
        

        
        i = '../vul_management/data/common/'+selected_file.split('/')[-1]
        info = ""
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            num = len(f.readlines())

        with open('../vul_management/vulnerability_management.txt', 'a+', encoding='utf-8') as f:
            info = str(num)+', '

            vul_kind = i.split('/')[-1].split('.java')[0]
            if "CWE" in vul_kind:
                pass
            else:
                vul_kind = "其他"
            info += vul_kind+', '

            info += i.split('/')[-1]+', '
            current_path = os.path.abspath(__file__)
            father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
            grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

            path = i.replace('../', grandfather_path+'/')
            info += path+'\n'
       
            f.write(info)
        self.vulnerability_management_flag -= 1
        self.vulnerability_management()
        #self.box.insert('','end',values=[i for i in info.split(', ')])
 


    def remove_vul_file(self):
        item = self.box.selection()[0]
        Temp_student_list = self.box.item(item, "values")
        try:
            os.remove(Temp_student_list[3].strip())
            print("Deletion success")
            new_centent = []
            with open("../vul_management/vulnerability_management.txt", "r", encoding='utf-8') as f:
                for num, i in enumerate(f.readlines()):
                    if num == int(Temp_student_list[0]):
                        pass
                    else:
                        new_centent.append(i)
            with open('../vul_management/vulnerability_management.txt', 'w', encoding='utf-8') as f:
                for i in new_centent:
                    f.write(i)
        except:
            print("None chosen")
        self.tl.destroy()
        self.vulnerability_management()

    def refresh_vul_file(self):
        self.tl.destroy()
        java_list = jp.load_directory_new('../vul_management/data')
        with open('../vul_management/vulnerability_management.txt', 'w', encoding='utf-8') as f:
            for num,i in enumerate(java_list):
                f.write(str(num)+', ')

                vul_kind = i.split('/')[-1].split('.java')[0]
                if "CWE" in vul_kind:
                    pass
                else:
                    vul_kind = "其他"
                f.write(vul_kind+', ')

                f.write(i.split('/')[-1]+', ')
                current_path = os.path.abspath(__file__)
                father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
                grandfather_path = os.path.abspath(os.path.dirname(father_path) + os.path.sep + ".")

                path = i.replace('../', grandfather_path+'/')
                f.write(path+'\n')

        self.vulnerability_management()
 


    def read_vul_data(self):
        java_list = jp.load_directory_new('../vul_management/data')
        with open('../vul_management/vulnerability_management.txt', 'r', encoding='utf-8') as f:
            line = f.readline()
            while line:
                yield line
                line = f.readline()
    def deal_line(self, op):
        while 1:
            try:
                line = next(op)
            except StopIteration:
                break
            else:
                self.box.insert('','end',values=[i for i in line.split(', ')])
                


    def select_directory1(self):
        selected_directory = filedialog.askdirectory()
        self.path_generation = selected_directory
        self.show_dataloader1.delete(0,END)
        self.show_dataloader1.insert(0,selected_directory)
    def select_directory2(self):
        selected_directory = filedialog.askdirectory()
        self.path_detection = selected_directory
        self.show_dataloader2.delete(0,END)
        self.show_dataloader2.insert(0,selected_directory)

         
    def open_folder(self):
        subprocess.Popen(
                ["xdg-open", os.path.join(os.getcwd(),"../temp")],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
                )
    def generator(self):
        print("="*50)
        print("开始加载数据")
        cfilelist = cp.load_directory_new(self.path_generation)
        javafilelist = jp.load_directory_new(self.path_generation)
        num_cfile = len(cfilelist)
        num_javafile = len(javafilelist)
        if num_cfile + num_javafile == 0:
            tk.messagebox.showinfo(title='LCVD', message='文件夹里没有C/C++/Java源代码文件，请重新选择')
            return 0
        else:
            print(f"此次检测共有{num_cfile+num_javafile}个文件")
        print("="*50)
        print("开始生成指纹")
        self.generator_process.delete(0,END)
        generation_start_time = time.time()
        old_progress = -1
        for idx, function_list in enumerate(pool.imap_unordered(pan_generation, cfilelist+javafilelist)):
            progress = int(idx//((num_cfile+num_javafile)/100))
            finish = int(progress/2)*"*"
            need_do = "-" * int(50 - progress/2)
            dur = time.time()-generation_start_time
            if progress > old_progress:
                progress_str = "进度:{:^3.0f}%[{}->{}]{:.2f}s".format(progress, finish, need_do, dur)
                print(progress_str)
                self.generator_process.delete(0, 0)
                self.generator_process.insert(0, progress_str)
                old_progress = progress

            length = 115
            if len((cfilelist+javafilelist)[idx])>length:
                firstline = (cfilelist+javafilelist)[idx][:length]
                secondline = (cfilelist+javafilelist)[idx][length:]
                self.generator_process.insert(1,firstline)
                self.generator_process.insert(2,secondline)
            else:
                self.generator_process.insert(1,(cfilelist+javafilelist)[idx])
            self.generator_process.delete(50, END)
            self.generator_process.update()
        print("进度100%，已经全部生成完成")
        self.generator_process.delete(0, 0)
        self.generator_process.insert(0,"进度100%，已经全部生成完成")
        tk.messagebox.showinfo(title='LCVD', message='脆弱性指纹生成完成')

    def detector(self):
        print("="*50)
        print("开始加载指纹")
        contents = []
        try:
            with open("../fingerprint/java_fingerprint.cvd") as f:
                contents = f.readlines()
        except Exception as e:
            print(e)
            print("No java fingerprints")
        try:
            with open("../fingerprint/c_fingerprint.cvd") as f:
                contents += f.readlines()
        except Exception as e:
            print(e)
            print("No c fingerprints")
        vul_fingerprint = [content.strip().split("===>")[0] for content in contents]
        vul_sourcefile = [content.strip().split("===>")[1] for content in contents]

        print("="*50)
        print("开始加载待测文件")
        cfilelist = cp.load_directory_new(self.path_detection)
        javafilelist = jp.load_directory_new(self.path_detection)
        candidate_filelist = cfilelist+javafilelist
        num_candidate = len(candidate_filelist)
        if num_candidate == 0:
            tk.messagebox.showinfo(title='LCVD', message='此文件夹中没有发现C/C++/JAVA源代码文件，请重新选择。')
            return 0
        else:
            print(f"此次检测共有{num_candidate}个文件")
        
        print("="*50)
        print("开始进行检测初始化操作")
        if not os.path.exists("../temp"):
            os.mkdir("../temp")
        if not os.path.exists("../logging"):
            os.mkdir("../logging")
        result_file_name = f"../temp/report-{datetime.datetime.now()}"
        logging_file_name = f"../logging/log{datetime.datetime.now()}"
        logging_file = open(logging_file_name, "w")

        num_vul = 0
        toolargefile = []
        parseerrorfile = []
        namingerrorfile = []
        old_progress = -1

        print("="*50)
        print("开始检测")
        self.detector_process.delete(0, END)
        detection_start_time = time.time()
        for idx, pan_result in enumerate(pool.imap_unordered(pan_detection, candidate_filelist)):

            progress = int(idx//((num_candidate)/100))
            finish = int(progress/2)*"*"
            need_do = "-" * int(50 - progress/2)
            dur = time.time() - detection_start_time

            if progress > old_progress:
                progress_str = "进度:{:^3.0f}%[{}->{}]{:.2f}s".format(progress, finish, need_do, dur)
                print(progress_str)
                self.detector_process.delete(0, 0)
                self.detector_process.insert(0, progress_str)
                old_progress = progress
            length = 115
            if len(candidate_filelist[idx])>length:
                firstline = candidate_filelist[idx][:length]
                secondline = candidate_filelist[idx][length:]
                self.detector_process.insert(1,firstline)
                self.detector_process.insert(2,secondline)
            else:
                self.detector_process.insert(1,candidate_filelist[idx])
            self.detector_process.delete(50, END)
            self.detector_process.update()

            if pan_result[2] == True:
                toolargefile.append(num_candidate[idx])
                continue
            try:
                logging_file.write(candidate_filelist[idx]+"\n")
            except:
                namingerrorfile.append(str(candidate_filelist[idx]).encode("utf-8","replace").decode())
                continue
            
            for candidate_finger,candidate_function in zip(pan_result[0],pan_result[1]):
                if candidate_finger in vul_fingerprint:
                    with open(result_file_name, "a") as result_file:
                            num_vul += 1
                            result_file.write(f"{candidate_filelist[idx]}文件中的{candidate_function}存在克隆漏洞风险\n")

        
        
            
        if os.path.exists(result_file_name):
            with open(result_file_name, "r") as result_file:
                contents_old = result_file.read()
        else:
            contents_old = ""
        with open(result_file_name, "w") as result_file:
            result_file.write(f"======本次检测一共包含{num_candidate}个文件，其中c语言文件为{len(cfilelist)}个，Java语言文件为{len(javafilelist)}个，检测出漏洞文件{num_vul}个======\n\n"+contents_old)
            if len(toolargefile) > 0 or len(parseerrorfile):
                result_file.write(f"\n\n======以下文件无法成功进行检测======\n")
                if len(toolargefile) > 0:
                    result_file.write(f"{len(toolargefile)}文件过大，不符合编程规范，建议重新拆分后检测，文件名如下：\n")
                    for file in toolargefile:
                        result_file.write(file+"\n")
                if len(parseerrorfile) > 0:
                    result_file.write(f"{len(parseerrorfile)}文件过大，不符合编程规范，建议重新拆分后检测，文件名如下：\n")
                    for file in toolargefile:
                        result_file.write(file+"\n")
                if len(namingerrorfile) > 0:
                    result_file.write(f"{len(parseerrorfile)}文件名编码错误，请重新命名，文件名如下：\n")
                    for file in namingerrorfile:
                        result_file.write(file+"\n")


        print("进度100%，已经全部检测完成")
        self.detector_process.delete(0, 0)
        self.detector_process.insert(0,"进度100%，已经全部检测完成")
        tk.messagebox.showinfo(title='LCVD', message=f'比对完成，检测结果见{result_file_name}')


def main():
    #check()
    screen = LCVDScreen()
    screen.mainloop()


if __name__=="__main__":
    cpu_count = get_cpu_count()
    pool = mp.Pool(processes = cpu_count-1)
    main()