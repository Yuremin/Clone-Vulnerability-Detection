import os
import re
import subprocess



class function:
    parent_file = None  # Absolute file which has the function
    parent_num_loc = None  # Number of LoC of the parent file
    name = None  # Name of the function
    lines = None  # Tuple (lineFrom, lineTo) that indicates the LoC of function
    funcId = None  # n, indicating n-th function in the file
    parameterlist = []  # list of parameter variables
    variablelist = []  # list of local variables
    datatypelist = []  # list of data types, including user-defined types
    funccalleelist = []  # list of called functions' names
    funcbody = None
    
    def __init__(self, filename):
        self.parent_file = filename
        self.parameter_list = []
        self.variable_list = []
        self.datatype_list = []
        self.funccallee_list = []



def load_directory(root_directory):

    source_file_list = []
    
    for root,dirs,files in os.walk(root_directory):
        for filename in files:
            if filename.endswith('.c') or filename.endswith('.cpp') or filename.endswith('.cc') or filename.endswith('.c++') or filename.endswith('.cxx'):
                absolute_filename = os.path.join(root, filename)
                source_file_list.append(absolute_filename)
    return source_file_list



def parsefile_shallow(source_file_name):
    java_call_command = "java -jar ../utils/FuncParser-opt.jar "
    java_call_command = java_call_command + source_file_name
    function_instance_list = []
    try:
        ast_string =  subprocess.check_output(java_call_command, stderr=subprocess.STDOUT, shell=True)
    except subprocess.CalledProcessError as e:
        print("Parse error:", e)
        ast_string = ""
    functionlist = ast_string.decode().split("\r\0?\r?\0\r")
    for func in functionlist[1:]:
        function_instance = function(source_file_name)
        elements_list = func.split('\n')[1:-1]
        if len(elements_list) > 9:
            function_instance.parent_num_loc = int(elements_list[1])
            function_instance.name = elements_list[2]
            function_instance.lines = (int(elements_list[3].split('\t')[0]), int(elements_list[3].split('\t')[1]))
            function_instance.funcId = int(elements_list[4])
            function_instance.funcbody = '\n'.join(elements_list[9:])

            function_instance_list.append(function_instance)
    return function_instance_list

def parsefile_deep(source_file_name):
    java_call_command = "java -jar ../utils/FuncParser-opt.jar "
    java_call_command = java_call_command + source_file_name
    function_instance_list = []
    try:
        ast_string =  subprocess.check_output(java_call_command, stderr=subprocess.STDOUT, shell=True)
    except subprocess.CalledProcessError as e:
        print("Parse error:", e)
        ast_string = ""

    functionlist = ast_string.decode().split("\r\0?\r?\0\r")
    for func in functionlist[1:]:
        function_instance = function(source_file_name)

        elements_list = func.split('\n')[1:-1]
        if len(elements_list) > 9:
            function_instance.parent_num_loc = int(elements_list[1])
            function_instance.name = elements_list[2]
            function_instance.lines = (int(elements_list[3].split('\t')[0]), int(elements_list[3].split('\t')[1]))
            function_instance.funcId = int(elements_list[4])
            function_instance.parameter_list = elements_list[5].rstrip().split('\t')
            function_instance.variable_list = elements_list[6].rstrip().split('\t')
            function_instance.datatype_list = elements_list[7].rstrip().split('\t')
            function_instance.funccallee_list = elements_list[8].rstrip().split('\t')
            function_instance.funcbody = '\n'.join(elements_list[9:])

            function_instance_list.append(function_instance)
    return function_instance_list





def remove_comment(string):
    c_regex = re.compile(
        r'(?P<comment>//.*?$|[{}]+)|(?P<multilinecomment>/\*.*?\*/)|(?P<noncomment>\'(\\.|[^\\\'])*\'|"(\\.|[^\\"])*"|.[^/\'"]*)',
        re.DOTALL | re.MULTILINE)
    return ''.join([c.group('noncomment') for c in c_regex.finditer(string) if c.group('noncomment')])

def normalization(string):
    return ''.join(string.replace('\n', '').replace('\r', '').replace('\t', '').replace('{', '').replace('}', '').split(' ')).lower()

def abstraction(instance, level):
    original_funcbody = instance.funcbody
    original_funcbody = remove_comment(original_funcbody)
    abstract_funcbody = original_funcbody
    
    if int(level) >= 1:  # PARAM
        parameter_list = instance.parameter_list
        for param in parameter_list:
            if len(param) == 0:
                continue
            try:
                paramPattern = re.compile("(^|\W)" + param + "(\W)")
                abstract_funcbody = paramPattern.sub("\g<1>FPARAM\g<2>", abstract_funcbody)
            except:
                pass

    if int(level) >= 2:  # DTYPE
        datatype_list = instance.datatype_list
        for dtype in datatype_list:
            if len(dtype) == 0:
                continue
            try:
                dtypePattern = re.compile("(^|\W)" + dtype + "(\W)")
                abstract_funcbody = dtypePattern.sub("\g<1>DTYPE\g<2>", abstract_funcbody)
            except:
                pass

    if int(level) >= 3:  # LVAR
        variable_list = instance.variable_list
        for lvar in variable_list:
            if len(lvar) == 0:
                continue
            try:
                lvarPattern = re.compile("(^|\W)" + lvar + "(\W)")
                abstract_funcbody = lvarPattern.sub("\g<1>LVAR\g<2>", abstract_funcbody)
            except:
                pass

    if int(level) >= 4:  # FUNCCALL
        funccallee_list = instance.funccallee_list
        for fcall in funccallee_list:
            if len(fcall) == 0:
                continue
            try:
                fcallPattern = re.compile("(^|\W)" + fcall + "(\W)")
                abstract_funcbody = fcallPattern.sub("\g<1>FUNCCALL\g<2>", abstract_funcbody)
            except:
                pass
    return (original_funcbody, abstract_funcbody)
