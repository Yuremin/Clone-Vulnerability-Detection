import os
import re
import subprocess



class function:
    parent_file = None  # Absolute file which has the function
    parent_num_loc = None  # Number of LoC of the parent file
    name = None  # Name of the function
    lines = None  # Tuple (lineFrom, lineTo) that indicates the LoC of function
    funcId = None  # n, indicating n-th function in the file
    parameterlist = []  # list of parameter variables
    variablelist = []  # list of local variables
    datatypelist = []  # list of data types, including user-defined types
    funccalleelist = []  # list of called functions' names
    funcbody = None
    
    def __init__(self, filename):
        self.parent_file = filename
        self.parameterlsit = []
        self.variablelist = []
        self.datatypelist = []
        self.funccalleelist = []



def load_directory(root_directory):

    source_file_list = []
    
    for root,dirs,files in os.walk(root_directory):
        for filename in files:
            if filename.endswith('.c') or filename.endswith('.cpp') or filename.endswith('.cc') or filename.endswith('.c++') or filename.endswith('.cxx'):
                absolute_filename = os.path.join(root, filename)
                source_file_list.append(absolute_filename)
    return source_file_list



def parsefile_shallow(source_file_name):
    java_call_command = "java -jar ../utils/FuncParser-opt.jar "
    java_call_command = java_call_command + source_file_name
    function_instance_list = []
    try:
        ast_string =  subprocess.check_output(java_call_command, stderr=subprocess.STDOUT, shell=True)
    except subprocess.CalledProcessError as e:
        print("Parse error:", e)
        ast_string = ""
    functionlist = ast_string.decode().split("\r\0?\r?\0\r")
    for func in functionlist[1:]:
        function_instance = function(source_file_name)
        elements_list = func.split('\n')[1:-1]
        if len(elements_list) > 9:
            function_instance.parent_num_loc = int(elements_list[1])
            function_instance.name = elements_list[2]
            function_instance.lines = (int(elements_list[3].split('\t')[0]), int(elements_list[3].split('\t')[1]))
            function_instance.funcId = int(elements_list[4])
            function_instance.funcbody = '\n'.join(elements_list[9:])

            function_instance_list.append(function_instance)
    return function_instance_list


def remove_comment(string):
    c_regex = re.compile(
        r'(?P<comment>//.*?$|[{}]+)|(?P<multilinecomment>/\*.*?\*/)|(?P<noncomment>\'(\\.|[^\\\'])*\'|"(\\.|[^\\"])*"|.[^/\'"]*)',
        re.DOTALL | re.MULTILINE)
    return ''.join([c.group('noncomment') for c in c_regex.finditer(string) if c.group('noncomment')])

def normalization(string):
    return ''.join(string.replace('\n', '').replace('\r', '').replace('\t', '').replace('{', '').replace('}', '').split(' ')).lower()

def abstraction(instance, level):
    original_funcbody = instance.funcbody
    original_funcbody = remove_comment(original_funcbody)
    abstract_funcbody = original_funcbody
    
    if int(level) >= 1:
        parameters_list = instance.parameters_list
        for param in parameters_list:
            if len(param) == 0:
                continue
            else:
                pass
    
    return (original_funcbody, abstract_funcbody)
